using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Immutable;
using TUnit.Assertions.SourceGenerator.AssertionHolder;
using TUnit.Assertions.SourceGenerator.GenerateAssertion;
using TUnit.Assertions.SourceGenerator.Helpers;

namespace TUnit.Assertions.SourceGenerator;

[Generator(LanguageNames.CSharp)]
public class GenerateAssertionsGenerator : IIncrementalGenerator {
    public void Initialize(IncrementalGeneratorInitializationContext context) {
        IncrementalValueProvider<ImmutableArray<AssertionHolderDto>> data = context.SyntaxProvider
            .CreateSyntaxProvider(Predicate, AssertionHolderDtoFactory.Create)
            .Where(dto => dto is not null && !dto.IsEmpty)
            .Collect()!;

        context.RegisterSourceOutput(context.CompilationProvider.Combine(data), GenerateFiles);
    }

    private static bool Predicate(SyntaxNode s, CancellationToken _) {
        return s is ClassDeclarationSyntax { AttributeLists.Count: > 0 };
    }

    private static void GenerateFiles(
        SourceProductionContext spc,
        (Compilation Compilation, ImmutableArray<AssertionHolderDto> DtoArray) box
    ) {
        (_, ImmutableArray<AssertionHolderDto> dtoArray) = box;
        var builder = new GeneratorStringBuilder();

        foreach (AssertionHolderDto holderDto in dtoArray) {
            builder.AppendAutoGenerated()
                .AppendUsings(
                    "TUnit.Assertions.Extensions",
                    "TUnit.Assertions.AssertConditions",
                    "TUnit.Assertions.AssertConditions.Interfaces",
                    "TUnit.Assertions.AssertionBuilders",
                    "TUnit.Assertions.AssertionBuilders.Wrappers"
                )
                .AppendNamespace(holderDto.Namespace)
                .AppendLine();

            builder.AppendLine($"public static partial class {holderDto.ClassName}")
                .AppendAutoClosedScope(scopeBuilder => {
                    scopeBuilder.ForEach(holderDto.GenerateAssertions, WriteFuncValueAssertCondition, spc);
                });

            spc.AddSource($"{holderDto.Namespace}.{holderDto.ClassName}.g.cs", builder.ToStringAndClear());
        }
    }

    private static void WriteFuncValueAssertCondition(GeneratorStringBuilder builder, GenerateAssertionDto assertionDto,
        SourceProductionContext context) {
        if (!GenerateAssertionDtoVerifier.TryVerifyOrGetDiagnostics(assertionDto, out ImmutableArray<Diagnostic> diagnostics)) {
            foreach (Diagnostic diagnostic in diagnostics) {
                context.ReportDiagnostic(diagnostic);
            }

            // Skip the generation of this assertion one as it is expected that it will cause issues.
            return;
        }

        builder.AppendBody(
            $$"""
              public static InvokableValueAssertionBuilder<{{assertionDto.TypeName}}> {{assertionDto.GetMethodName()}}(this IValueSource<{{assertionDto.TypeName}}> valueSource)
              {
                  return valueSource.RegisterAssertion(new FuncValueAssertCondition<{{assertionDto.TypeName}}, int>(0,
                      (value, _, self) =>
                      {
                          {{assertionDto.GetNullCheck()}}
                          return {{assertionDto.GetActualCheck()}};
                      },
                      {{assertionDto.GetMessageFactoryOrDefault()}},
                      {{assertionDto.GetExpectationExpressionOrDefault()}}),
                      []
                  ); 
              }
              """);
    }
}